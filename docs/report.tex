\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Разработка базы данных для хранения и обработки данных авиакомпании}
    {В.~Марченко/ИУ7-63Б}
    {Д.~А.~Шибанова}
    {}
    
\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка 53 с., 12 рис., 9 табл., 18 источн., 1 прил.

\noindent АВИАБИЛЕТЫ, АВИАПЕРЕЛЕТЫ, БАЗЫ ДАННЫХ, ВЕБ-ПРИЛОЖЕНИЕ, РЕЛЯЦИОННАЯ МОДЕЛЬ ДАННЫХ, SQL

Объектом разработки является база данных и приложение к ней.

Объектом исследования являются кластеризованные и некластеризованные индексы.

Цель работы: разработка базы данных для хранения и обработки данных авиакомпании и веб-приложения, которое будет ее использовать.

В результате выполнения работы была разработана база данных для хранения и обработки данных авиакомпании и веб-приложение, использующее эту базу данных.

В ходе выполнения конструкторской части были выделены шесть сущностей: пользователь, заказ, рейс, билет, самолет и услуга. 
А также три роли на уровне базы данных: клиент, модератор и администратор.

При выполнении технологической части были выбраны средства реализации программного обеспечения (язык программирования C\texttt{\#} и система управления базами данных Microsoft SQL Server), реализован интерфейс доступа к базе данных и проведено тестирование разработанного функционала (mock-тесты, интеграционные тесты и тесты по сценариям использования).

В ходе проведения исследования было установлено, что при 250 тысячах строк в таблице использование и кластеризованного, и некластеризованного индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней на примере одной из таблиц спроектированной базы данных.

Область применения результатов --- дальнейшее развитие и расширение приложения для поиска и покупки билетов на любые виды транспорта.

{\centering \maketableofcontents}

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
БД & База данных
\tabularnewline
ПО & Программное обеспечение
\tabularnewline
СУБД & Система управления базами данных
\tabularnewline
ER-диаграмма & Диаграмма <<сущность-связь>> (от англ. entity-relationship)
\tabularnewline
GPS & Система глобального позиционирования (Global Positioning System)
\tabularnewline
ID & Идентификатор
\tabularnewline
MPA & Многостраничное приложение (Multi Page Application)
\tabularnewline
SPA & Одностраничное приложение (Single Page Application)
\tabularnewline
Use case диаграмма & Диаграмма вариантов использования
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Системы баз данных широко распространены в корпоративном мире как видимый инструмент --- сотрудники часто напрямую взаимодействуют с такими системами, чтобы отправить данные или создать отчеты. 
Но не менее часто они используются как невидимые компоненты программных систем. 
Например, веб-сайт электронной коммерции, использующий базу данных на стороне сервера для хранения информации о клиентах, товарах и продажах. 
Или система навигации GPS, использующая встроенную базу данных для управления картами дорог. 
В обоих этих примерах система баз данных скрыта от пользователя; с ней взаимодействует только код приложения~\cite{Sciore2020}.

Наряду с веб-сайтами электронной коммерции, веб-приложения для покупки авиабилетов также используют базы данных для хранения информации о пользователях, самолетах, билетах и т.~д. 
Существует мнение, что самолет --- лучший способ передвижения. 
Эту точку зрения подкрепляют несколько факторов:
\begin{enumerate}
\item[1)] самый быстрый путь к месту назначения;
\item[2)] авиабилеты являются доступными для среднестатистического человека;
\item[3)] полет --- один из самых безопасных способов путешествовать~\cite{Ataturk2021}.
\end{enumerate}

Целью курсовой работы является разработка базы данных для хранения и обработки данных авиакомпании, а также веб-приложения, которое будет ее использовать.

Задачами данной работы являются:
\begin{enumerate}
\item[1)] провести обзор существующих веб-приложений для покупки авиабилетов и сформулировать требования и ограничения к разрабатываемой базе данных и приложению;
\item[2)] спроектировать архитектуру базы данных, ограничения целостности и ролевую модель на уровне базы данных;
\item[3)] выбрать средства реализации и реализовать спроектированную базу данных и необходимый интерфейс для взаимодействия с ней;
\item[4)] исследовать характеристики разработанного программного обеспечения.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Анализ предметной области}

Одно из самых популярных средств для поиска авиабилетов --- Aviasales~\cite{Aviasales}. 
Это метапоисковик билетов, и сама компания перелеты не организует. 
Так как целью курсовой работы является разработка базы данных для хранения и обработки данных авиакомпании, стоит рассмотреть сервисы, которые предоставляют возможность покупки билетов на самолеты, принадлежащие тем или иным организациям.

Из довольно известных международных компаний, у которых есть собственный флот, можно выделить следующие: Qatar Airways~\cite{QatarAirways}, Emirates~\cite{Emirates} и United Airlines~\cite{UnitedAirlines}. 

Можно сразу выделить тот факт, что в приложении United Airlines есть возможность переключения пользовательского интерфейса на 8 языков, в то время как Qatar Airways и Emirates предлагают на выбор свыше 70 языков. 
На домашней странице всех приложений пользователю сразу предлагается выбрать пункт вылета и прибытия, тип билета --- в одну сторону или <<туда и обратно>>, даты вылета и обратного рейса, количество билетов и их классы. 
Emirates и United Airlines помимо экономкласса, бизнес-класса и первого класса предлагают билеты премиального экономкласса. 
Кроме того, во всех приложениях доступны такие функции как онлайн регистрация, управление бронированием и проверка статуса рейса. 
Еще одно достоинство трех приложений --- нет необходимости регистрироваться для поиска билетов. 
Регистрация нужна только в случае, если нужно купить билет.

С другой стороны, все три приложения обладают большим недостатком. 
Они слишком <<перегружены>> различного рода информацией для пользователя. 
Например, Qatar Airways предлагает купить пакет, в который входят билеты, бронирование отеля и билеты на Формулу 1. 
Другие приложения предлагают забронировать множество отелей в различных городах мира. 
Пользователя, который хочет быстро приобрести билет на интересующий его рейс, вся эта информация будет отвлекать. 
Поэтому одна из задач данной курсовой работы --- создание простого, интуитивно понятного приложения для поиска авиабилетов. 
На рисунках~\ref{img:gui-01}--\ref{img:gui-03} показаны графические интерфейсы пользователя трех рассматриваемых приложений для поиска авиабилетов.

\includeimage
    {gui-01}
    {f}
    {H}
    {0.9\textwidth}
    {Графический интерфейс пользователя приложения Qatar Airways}
    
\includeimage
    {gui-02}
    {f}
    {H}
    {0.9\textwidth}
    {Графический интерфейс пользователя приложения Emirates}
    
\includeimage
    {gui-03}
    {f}
    {H}
    {0.9\textwidth}
    {Графический интерфейс пользователя приложения United Airlines}

\section{Требования к базе данных и приложению}

Приложение должно предоставлять пользователям возможность искать билеты на интересующие их рейсы. 
Для этого должны быть использованы следующие параметры: дата вылета, пункт вылета и пункт прибытия. 
Билеты могут быть нескольих классов. 
Помимо билетов пользователь может выбирать услуги, которые предоставляются для билетов определенных классов.

Пользователи должны иметь возможность просматривать заказ, добавлять билеты в заказ, удалять их оттуда, удалять и оплачивать заказ, добавлять и удалять услуги.
 
Должны быть реализованы регистрация и авторизация пользователей, внесение именений в личные данные и возможность просмотреть информацию о самолетах авиакомпании.

\section{Модели баз данных}

\subsection{Дореляционные базы данных}

В основе любой базы данных лежит модель данных. 
Моделью данных называется формализованное описание структур единиц информации и операций над ними в информационной системе. 
Тип модели данных определяет логическую структуру базы данных и то, каким образом данные могут быть сохранены, организованы и обработаны~\cite{Avrunev2018}.

К ранним моделям относят модели, предшествующие реляционной
модели данных: иерархическую, сетевую модели и модель на основе инвертированных списков. 
Иерархическая модель данных была исторически первой структурой
баз данных, видимо, из-за того, что древовидные иерархические структуры широко используются в повседневной человеческой деятельности~\cite{Avrunev2018}.

Иерархическая модель данных --- представление базы данных в виде древовидной (иерархической) структуры, состоящей из объектов (данных) различных уровней~\cite{Avrunev2018}.

В этой модели данные представляются как дерево связанных записей. 
Имеется один корневой (родительский) тип записи --- корень дерева. 
С ним в подчиненной связи типа 1:N находятся дочерние записи. 
Связи между записями выражаются в виде отношений предок-потомок, а у каждой записи есть ровно одна родительская запись. 
Это помогает поддерживать ссылочную целостность: когда запись удаляется из дерева, все ее потомки должны быть также
удалены~\cite{Avrunev2018}.

Иерархические базы данных имеют централизованную структуру,
поэтому безопасность данных легко контролировать. 
Однако, определенные знания о физическом порядке хранения записей все же необходимы, так как отношения предок-потомок реализуются в виде физических указателей из одной записи на другую. 
Это означает, что поиск записи осуществляется методом прямого обхода дерева. 
Записи, расположенные в одной половине дерева, ищутся быстрее, чем в другой. 
Отсюда следует необходимость правильно упорядочивать записи, чтобы время их поиска было минимальным~\cite{Avrunev2018}.

Достоинства иерархической модели.

\begin{enumerate}
\item Принцип построения баз данных в иерархической модели легок для понимания. 
Иерархия базы данных напоминает структуру компании или генеалогическое дерево.
\item Использование отношений предок-потомок. 
Иерархическая модель позволяет легко представлять отношения предок-потомок, например, <<А является частью В>> или <<А принадлежит В>>.
\item Быстродействие. 
В иерархической модели отношения предок-потомок реализуются в виде физических указателей из одной записи на другую, поэтому перемещение по базе данных происходит достаточно быстро. 
Поскольку структура данных в иерархической модели отличается простотой, СУБД может размещать записи предков и
потомков на диске рядом друг с другом, что позволяло свести к минимуму количество операций чтения-записи~\cite{Avrunev2018}.
\end{enumerate}

Недостатки иерархической модели.

\begin{enumerate}
\item Операции манипулирования данными в иерархических системах ориентированы прежде всего на поиск информации сверху вниз, т.~е. по данному экземпляру сегмента-отца можно найти все экземпляры сегментов-сыновей. 
Обратный поиск затруднен, а часто и невозможен. 
Например, попытка реализовать запрос типа <<В скольких сборниках статей опубликовал свои статьи господин Петров?>> может оказаться весьма трудной задачей.
\item Дублирование данных на логическом уровне.
\item Для представления связи M:N необходимо дублирование деревьев.
\item В иерархической модели автоматически поддерживается целостность ссылок между предками и потомками по правилу: никакой потомок не может существовать без своего родителя. 
Целостность по ссылкам между записями, не входящими в одну иерархию, не поддерживается. 
Поэтому невозможно хранение в базе данных порожденного узла без соответствующего исходного. 
Аналогично, удаление исходного узла влечет удаление всех порожденных узлов (деревьев), связанных с ним~\cite{Avrunev2018}.
\end{enumerate}

Сетевой подход к организации данных является расширением
иерархического. 
Цель разработчиков сетевой модели --- создание модели, позволяющей описывать связи M:N, чтобы одна запись могла участвовать в нескольких отношениях предок-потомок~\cite{Avrunev2018}.

Сетевая модель данных базируется также на использовании представления данных в виде графа. 
C точки зрения теории графов сетевой модели соответствует произвольный граф: если в иерархической модели запись-потомок должна иметь в точности одного предка, то в сетевой модели данных потомок может иметь любое число предков. 
Вершины графа используются для интерпретации типов объектов, дуги графа используются для интерпретации типов связей между типами объектов~\cite{Avrunev2018}.

Структура сетевой базы данных основана на следующих правилах:

\begin{enumerate}
\item[1)] база данных содержит любое количество типов записей и типов наборов;
\item[2)] между двумя типами записей может быть определено любое количество типов наборов;
\item[3)] тип записи может быть владельцем и одновременно членом нескольких типов наборов~\cite{Avrunev2018}.
\end{enumerate}

Сложность практического использования иерархических и сетевых
СУБД заставляла искать иные способы представления данных. 
В конце 1960-х годов появились СУБД на основе инвертированных файлов, отличающиеся простотой организации и наличием весьма удобных языков манипулирования данными. Организация доступа к данным на основе инвертированных списков используется практически во всех современных реляционных СУБД, но в реляционных СУБД пользователи не имеют непосредственного доступа к инвертированным спискам (индексам)~\cite{Avrunev2018}.

База данных на инвертированных списках похожа на реляционную
базу данных, т.~е. также состоит из таблиц отношений, однако ей присущи важные отличия:

\begin{enumerate}
\item[1)] допускается сложная структура атрибутов (атрибуты не обязательно атомарны);
\item[2)] строки таблиц (записи) упорядочены в некоторой последовательности, каждой строке присваивается уникальный номер, физическая упорядоченность строк всех таблиц может определяться и для всей базы данных;
\item[3)] пользователям видны и хранимые таблицы, и пути доступа к ним;
\item[4)] пользователь может управлять логическим порядком строк в каждой таблице с помощью специального инструмента --- индексов (эти индексы автоматически поддерживаются системой и явно видны пользователям)~\cite{Avrunev2018}.
\end{enumerate}

Недостаток модели --- отсутствие строгого математического аппарата, отсутствие средств для описания ограничений целостности базы данных и, как следствие --- большая трудоемкость программирования запросов к базе данных. 
В некоторых системах поддерживаются ограничения уникальности значений некоторых полей, но в основном все возлагается на
прикладную программу. 
Кроме этого, такие СУБД обладают рядом ограничений на количество файлов для хранения данных, количество
связей между ними, длину записи и количество ее полей~\cite{Avrunev2018}.

\subsection{Реляционные базы данных}

Реляционные базы данных относят ко второму поколению баз данных. 
Они появились в начале 70-х годов ХХ века и активно использовались до конца 90-х годов ХХ века. 
Считается, что их теорию сформулировал Эдгар Кодд. 
Особенность реляционных баз данных состоит в том, что все данные и связи между ними хранятся в таблицах. 
Для определения структуры данных и манипулирования их значениями используют язык SQL (Structured Query Language --- структурированный язык запросов)~\cite{Vinogradov2016}.

Реляционная модель БД --- логическая модель, базирующаяся на концептуальной модели, например, модели сущность–связь, и используемая для построения схемы (структуры) реляционной БД. 
Управление реляционной БД осуществляется реляционной СУБД~\cite{Vinogradov2016}.

Факторы, обеспечившие быстрое распространение реляционной
модели:

\begin{enumerate}
\item[1)] с прагматической точки зрения база данных представляется в виде двумерных таблиц (отношений), обработка в которых не зависит от организации хранения данных в памяти;
\item[2)] с математической точки зрения реляционная база данных --- конечный набор отношений различной арности, являющихся областью приложений математической логики, теории множеств и общей алгебры, замкнутость реляционной модели (операции над отношениями дают отношение) обеспечивает основу для интерпретации выводимости, избыточности и непротиворечивости данных;
\item[3)] наличие небольшого набора абстракций, которые позволяют сравнительно просто моделировать большую часть распространенных предметных областей и допускают точные формальные определения~\cite{Avrunev2018}.
\end{enumerate}

Достоинства реляционной модели данных:

\begin{enumerate}
\item[1)] гарантия целостности данных при их обновлении;
\item[2)] низкий риск потери информации;
\item[3)] соответствие требованиям к транзакционным системам (ACID);
\item[4)] простое представление и формирование базы данных;
\item[5)] универсальность и удобство обработки данных, которая осуществляется с помощью декларативного языка запросов SQL (Structured Query Language)~\cite{Karpova2009}.
\end{enumerate}

Недостатки реляционной модели данных:

\begin{enumerate}
\item[1)] отсутствие специальных средств для отображения различных типов связей и агрегатов;
\item[2)] при нормализации отношений данные об одной сущности предметной области распределяются по нескольким таблицам, что усложняет работу с БД~\cite{Karpova2009};
\item[3)] отсутствие специальных механизмов навигации~\cite{Karpova2005}.
\end{enumerate}

\subsection{Постреляционные базы данных}

Третье поколение баз данных, называемых постреляционные, начало развиваться с 90-годов ХХ века. 
Тогда появились объектные, объектно-реляционные и полуструктрированные базы данных, которые расширяют возможности реляционных баз данных и позволяют хранить и обрабатывать как атомарные значения, так и объекты со сложной структурой. 
Объектные базы данных, основанные на объектно-ориентированной парадигме, --- альтернатива реляционному подходу. 
Объектно-реляционные базы данных поддерживают обратную совместимость с реляционными базами и расширяют их
возможности. 
Полуструктурированные базы данные развиваются параллельно на основе сетевых и иерархических баз данных и позволяют работать с частично структурированными данными~\cite{Vinogradov2016}.

Объектный подход к созданию баз данных ориентирован на объединение возможностей объектно-ориентированного языка программирования и базы данных для совместной работы. 
Он предполагает постоянное хранение объектов программы в базе данных и формирование запросов к базе данных на языке написания программы~\cite{Vinogradov2016}.

Объектная СУБД обладает следующими возможностями:
\begin{enumerate}
\item[1)] поддерживает сложную систему типов, в том числе атомарные, структуры, коллекции и ссылки и предоставляет средства для их описания;
\item[2)] разделяет работу с литералами (неизменяемыми значениями любых типов) и объектами классов;
\item[3)] обеспечивает идентификацию объектов;
\item[4)] позволяет определять иерархии классов и интерфейсов~\cite{Vinogradov2016}.
\end{enumerate}

Объектно-реляционная модель БД предоставляет пользователю следующие возможности:
\begin{enumerate}
\item[1)] хранить и обрабатывать сложные типы данных (структуры и коллекции);
\item[2)] наряду с предопределенными типами данных использовать пользовательские типы данных;
\item[3)] включать в пользовательские типы данных атрибуты и методы;
\item[4)] поддерживать уникальные идентификаторы кортежей и ссылки на них;
\item[5)] определять иерархию (наследование) типов данных~\cite{Vinogradov2016}.
\end{enumerate}

Поддерживает следующие типы данных:
\begin{enumerate}
\item[1)] атомарные;
\item[2)] структуры, содержащие набор именованных полей;
\item[3)] массивы, хранящие упорядоченный набор элементов;
\item[4)] множества и мультиможества, хранящие неупорядоченный набор элементов;
\item[5)] пользовательские типы данных;
\item[6)] ссылки на объекты (кортежи) пользовательских типов данных~\cite{Vinogradov2016}.
\end{enumerate}

Преимущество баз данных с фиксированной схемой, например, реляционных, --- высокая эффективность обработки и хранения больших объемов данных. 
Основным преимуществом полуструктурированных баз данных является их гибкость. 
Модель полуструктурированных данных позволяет хранить внутри данных не только значения, но и их структуру и изменять ее со временем. 
Полуструктурированные данные изображают с помощью графа. 
Вершины графа --- информационные элементы, а дуги --- связи между ними~\cite{Vinogradov2016}.

Полуструктрированные данные применяют:
\begin{enumerate}
\item[1)] для описания схожей информации в БД с отличающимися схемами данных при их интеграции;
\item[2)] для представления документов (по аналогии с языком XML для веб-сайтов);
\item[3)] для работы с унаследованными БД при укрупнении, поглощении компаний (описывают обобщенную структуру исходных БД)~\cite{Vinogradov2016}.
\end{enumerate}

\section{Информация, подлежащая хранению в базе данных}

В базе данных нужно будет хранить информацию о шести сущностях: пользователь, заказ, билет, рейс, самолет и услуга.
\begin{enumerate}
\item Пользователь. 
Информация о зарегистрированных пользователях: роль, адрес электронной почты, пароль, имя, фамилия и дата регистрации.
\item Заказ. 
Информация о заказах зарегистрированных пользователей: заказчик билета и статус заказа.
\item Рейс. 
Информация о рейсах, на которые продаются билеты. 
Пункт вылета, пункт прибытия, дата и время вылета, дата и время прибытия.
\item Билет.
Информация о продаваемых билетах. 
Рейс, на который продается билет, заказ, в котором находится текущий билет, номер ряда, место, класс, возможность возврата и стоимость. 
\item Самолет. 
Информация о самолетах, которые выполняют рейсы. 
Название компании-производителя, модель, количество мест экономкласса, бизнес-класса и первого класса.
\item Услуга. 
Информация о предоставляемых услугах. 
Наименование, стоимость, возможность получения данной услуги для билета экономкласса, бизнес-класса и первого класса.
\end{enumerate}

Рассмотрим несколько факторов, исходя из которых будет выбрана модель данных:

\begin{enumerate}
\item[1)] выделенные в текущем разделе шесть сущностей представляют собой структурированные данные, структура которых не подвержена частым изменениям;
\item[2)] важно соблюдать целостность и структуризацию хранимых данных;
\item[3)] разрабатываемое в ходе выполнения данной курсовой работы программное обеспечение предназначено для покупки авиабилетов, поэтому выбираемая модель данных должна соответствотвать требованиям к транзакционным системам (ACID);
\item[4)] в рамках проектируемой базы данных отсутствует необходимость хранения коллекций.
\end{enumerate}
 
Исходя из перечисленных причин, подходящей моделью данных является реляционная.

\pagebreak
\section{ER-диаграмма сущностей базы данных}

На рисунке~\ref{img:er} показана диаграмма <<сущность-связь>> проектируемой базы данных в нотации Чена. 
Представлены шесть сущностей и их свойства.

\includeimage
    {er}
    {f}
    {H}
    {1\textwidth}
    {ER-диаграмма}
    
\section{Пользователи приложения}

Пользователи приложения могуть быть четырех типов: посетители, клиенты, модераторы и администраторы.

Посетитель --- неавторизованный пользователь. 
Он может только искать рейсы и билеты, просматривать самолеты компании, регистрироваться и входить в личный кабинет.

Клиент --- зарегистрированный и авторизованный пользователь. 
Он может взаимодействовать с заказом: может его создать и просмотреть, добавить и удалить билеты, добавить и удалить услуги, очистить или оплатить заказ. 
Также у клиента должна быть возможность внести изменения в свои данные --- адрес электронной почты, имя и фамилию. 

Модератор --- зарегистрированный и авторизованный пользователь, который может добавлять в базу данных новые рейсы и билеты или удалять их оттуда.

Администратор может удалять учетные записи пользователей через приложение, а также имеет полный доступ к базе данных и, соответственно, может создавать новые таблицы или удалять старые. 
Администратор может напрямую работать с базой данных без приложения.

\pagebreak
\section{Диаграмма вариантов использования}

На рисунках~\ref{img:use-case-01}--\ref{img:use-case-03} показаны use case диаграммы для разных пользователей.

\includeimage
    {use-case-01}
    {f}
    {H}
    {.9\textwidth}
    {Взаимодействие пользователя с личными данными}
    
\includeimage
    {use-case-04}
    {f}
    {H}
    {.9\textwidth}
    {Администрирование}
    
\includeimage
    {use-case-02}
    {f}
    {H}
    {1\textwidth}
    {Взаимодействие пользователя с заказом}
    
\includeimage
    {use-case-03}
    {f}
    {H}
    {1\textwidth}
    {Поиск рейсов и билетов}

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы был проведен анализ предметной области; сформулированы требования к базе данных и приложению; выделены шесть сущностей базы данных --- пользователь, заказ, билет, рейс, услуга и самолет; проведен анализ существующих баз данных на основе формализации данных и выбрана реляционная модель; описаны пользователи приложения (посетители, клиенты, модераторы и администраторы) и пользовательские сценарии в виде use case диаграмм.

\chapter{Конструкторская часть}

\section{Описание сущностей базы данных}

В аналитической части были выделены шесть сущностей базы данных: пользователь, рейс, билет, самолет, услуга и заказ. 
На рисунке~\ref{img:db-diagram} представлена диаграмма базы данных.

\includeimage
    {db-diagram}
    {f}
    {H}
    {.9\textwidth}
    {Диаграмма базы данных}

В таблицах~\ref{tabular:users}--\ref{tabular:services} описаны атрибуты таблиц базы данных.

\begin{table}[H]
\caption{Атрибуты таблицы <<Пользователи>>}
\label{tabular:users}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Role & строка & Роль пользователя
\tabularnewline
\hline
Email & строка & Адрес электронной почты
\tabularnewline
\hline
Password & строка & Зашифрованный пароль
\tabularnewline
\hline
FirstName & строка & Имя пользователя
\tabularnewline
\hline
LastName & строка & Фамилия пользователя
\tabularnewline
\hline
RegDate & дата и время & Дата и время регистрации
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Заказы>>}
\label{tabular:orders}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
UserId & целое & Идентификатор пользователя --- внешний ключ
\tabularnewline
\hline
Status & строка & Статус заказа
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы-связки <<Билеты-Услуги>>}
\label{tabular:tickets_services}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
TicketId & целое & Идентификатор билета --- первичный и внешний ключ
\tabularnewline
\hline
ServiceId & целое & Идентификатор услуги --- первичный и внешний ключ
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Билеты>>}
\label{tabular:tickets}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
FlightId & целое & Идентификатор рейса --- внешний ключ
\tabularnewline
\hline
OrderId & целое & Идентификатор заказа
\tabularnewline
\hline
Row & целое & Ряд в самолете
\tabularnewline
\hline
Place & символ & Место в ряду
\tabularnewline
\hline
Class & строка & Класс билета
\tabularnewline
\hline
Refund & логический тип & Возможен ли возврат билета
\tabularnewline
\hline
Price & денежный тип & Стоимость
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Рейсы>>}
\label{tabular:flights}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
PlaneId & целое & Идентификатор самолета --- внешний ключ
\tabularnewline
\hline
DeparturePoint & строка & Пункт вылета
\tabularnewline
\hline
ArrivalPoint & строка & Пункт прибытия
\tabularnewline
\hline
DepartureDateTime & дата и время & Дата и время вылета
\tabularnewline
\hline
ArrivalDateTime & дата и время & Дата и время прибытия
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Самолеты>>}
\label{tabular:planes}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Manufacturer & строка & Название компании-производителя
\tabularnewline
\hline
Model & строка & Название модели самолета
\tabularnewline
\hline
EconomyClassNum & целое & Количество мест экономкласса
\tabularnewline
\hline
BusinessClassNum & целое & Количество мест бизнес-класса
\tabularnewline
\hline
FirstClassNum & целое & Количество мест первого класса
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Услуги>>}
\label{tabular:services}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Name & строка & Название услуги
\tabularnewline
\hline
Price & денежный тип & Стоимость услуги
\tabularnewline
\hline
EconomyClass & логический тип & Доступна ли услуга для билета экономкласса
\tabularnewline
\hline
BusinessClass & логический тип & Доступна ли услуга для билета бизнес-класса
\tabularnewline
\hline
FirstClass & логический тип & Доступна ли услуга для билета первого класса
\tabularnewline
\hline
\end{tabular}
\end{table}

\section{Описание ограничений целостности базы данных}

На данные, хранящиеся в базе, должны быть наложены определенные ограничения для обеспечения ее целостности.

Ограничения для таблицы <<Пользователи>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Роль пользователя не может отсутствовать.
Адрес электронной почты не может отсутствовать и должен быть уникальным. 
Пароль не может отсутствовать. 
Дата регистрации пользователя не должна отсутствовать.

Ограничения для таблицы <<Заказы>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор пользователя --- положительное число, внешний ключ, не должен отсутствовать. 
Статус не должен отсутствовать.

Ограничения для таблицы <<Рейсы>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор самолета --- положительное число, внешний ключ, не должен отсутствовать. 
Пункты вылета и прибытия не должны отсутствовать. 
Дата и время вылета и прибытия не должны отсутствовать, притом дата и время вылета должны быть меньше даты и времени прибытия. 

Ограничения для таблицы <<Билеты>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор рейса --- положительное число, внешний ключ, не должен отсутствовать. 
Ряд в самолете --- положительное число, не должен отсутствовать. 
Место в ряду не должно отсутствовать. 
Класс не должен отсутствовать. 
Возможность возврата не должна отсутствовать. 
Стоимость --- положительное число, не должна отсутствовать.

Ограничения для таблицы <<Самолеты>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Производитель и модель не должны отсутствовать. 
Количество мест разных классов --- неотрицательные числа, не должны отсутствовать. 

Ограничения для таблицы <<Услуги>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Наименование услуги не должно отсутствовать. 
Стоимость --- положительное число, не должна отсутствовать.
Доступность для мест разных классов не должна отсутствовать.

Ограничения для таблицы-связки <<Билеты-Услуги>>. 
Идентификатор билета --- положительное число, первичный и внешний ключ. 
Идентификатор услуги --- положительное число, первичный и внешний ключ. 

\pagebreak
\section{Описание проектируемой функции на уровне базы данных}

Пользователь приложения может заказывать билеты и услуги. 
Так как они находятся в разных таблицах, нужно выполнять два запроса для того, чтобы посчитать стоимость всех билетов и услуг, заказанных пользователем. 
Для этой цели удобно реализовать функцию, которая по идентификатору заказа будет возвращать его стоимость. 
На рисунке~\ref{img:function} представлена схема проектируемой функции.

\includeimage
    {function}
    {f}
    {H}
    {0.6\textwidth}
    {Функция, возвращающая стоимость заказа}

В функции используются следующие переменные:

\begin{enumerate}
\item[1)] orderId --- идентификатор заказа (входной параметр);
\item[2)] result --- стоимость заказа (выходной параметр);
\item[3)] sumTickets --- стоимость билетов, входящих в заказ;
\item[4)] sumServices --- стоимость услуг для билетов, входящих в заказ.
\end{enumerate}

\section{Описание ролевой модели на уровне базы данных}

В аналитической части было указано, что в приложении есть четыре типа пользователей: посетители, клиенты, модераторы и администраторы. 
Взаимодействией пользователей с базой данных должно происходить не напрямую, а с помощью определенного промежуточного слоя. 
Таким образом, для посетителя можно вообще не создавать роль на уровне базы данных. 
При попытке зазать билет, пользователь будет переадресован на страницу регистрации. 
Для трех других типов пользователей нужно создавать роли.

Доступны три роли на уровне базы данных.
\begin{enumerate}
\item Клиент взаимодействует с базой данных через приложение и получает информацию о рейсах, билетах, самолетах, услугах и своих заказах. 
Также клиент может изменить информацию о себе, которая хранится в таблице <<Пользователи>>.
\item Модератор обладает всеми правами клиента. 
Он тоже взаимодействует с базой данных через приложение и может добавлять информацию о билетах и рейсах или удалять ее. 
\item Администратор обладает всеми правами модератора. 
Он взаимодействует с базой данных и через приложение, и напрямую. 
Администратор может добавлять, удалять или изменять любую информацию, которая хранится в базе данных.
\end{enumerate}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы была создана диграмма базы данных; описаны сущности базы данных; описаны проектируемые ограничения целостности базы данных; описана функция на уровне базы данных, которая считает стоимость заказа, в виде схемы алгоритма и описана проектируемая ролевая модель на уровне базы данных, которая состоит из трех ролей --- клиент, модератор и администратор.

\chapter{Технологическая часть}

\section{Средства реализации}

Веб-приложения бывают одностраничными (SPA) и многостраничными (MPA). 
Оба подхода используются для разных целей и имеют свои преимущества и недостатки.

Одностраничные приложения обладают следующими преимуществами:

\begin{enumerate}
\item[1)] SPA загружают необходимые компоненты только один раз, а последующие обновления страницы выполняются динамически, не требуя полной перезагрузки страницы, что приводит к ускорению загрузки страниц и более плавному взаимодействию с пользователем;
\item[2)] SPA легче поддерживать, поскольку они используют модульную конструкцию, где каждый компонент отвечает за свою функциональность, что упрощает изменение или замену компонентов, не затрагивая другие части приложения;
\item[3)] запросы к серверу сведены к минимуму, поскольку приложение использует программный интерфейс (API) для извлечения данных с сервера, а не требует, чтобы сервер создавал целую страницу для каждого запроса;
\item[4)] когда пользователь находится в автономном режиме, SPA может отображать кэшированную версию веб-приложения, чтобы пользователь мог продолжать использовать приложение даже при отсутствии подключения к Интернету;
\item[5)] клиентская и серверная части приложения разделены, что позволяет разработчикам изменять одно, не затрагивая другое~\cite{Davidson2023}.
\end{enumerate}

Несмотря на свои преимущества, одностраничные приложения имеют несколько существенных недостатков:

\begin{enumerate}
\item[1)] поскольку SPA загружают весь свой контент одновременно, первоначальная загрузка может занять больше времени, что может быть проблемой для пользователей с медленным подключением к Интернету или старых устройств;
\item[2)] SPA трудно оптимизировать для поисковых систем, потому что они обычно имеют только один URL-адрес и ограниченный контент при начальной загрузке страницы, что влияет на их рейтинг в поисковых системах;
\item[3)] SPA могут быть несовместимы со старыми браузерами или устройствами, что может ограничить потенциальную базу пользователей;
\item[4)] поскольку большая часть логики приложения выполняется на стороне клиента, оно может быть более уязвимо для определенных типов атак, таких как межсайтовый скриптинг или подделка межсайтовых запросов~\cite{Davidson2023}.
\end{enumerate}

Преимущества многостраничных приложений:

\begin{enumerate}
\item[1)] MPA, как правило, хорошо ранжируются в результатах поисковых систем, поскольку каждая страница имеет уникальный URL-адрес и может быть проиндексирована отдельно, что означает, что каждая страница в MPA может занимать независимое место в результатах поиска, потенциально увеличивая трафик на сайт;
\item[2)] поскольку MPA отправляют отдельные запросы для каждой страницы, проще реализовать меры безопасности, такие как аутентификация и авторизация;
\item[3)] в то время как SPA обеспечивают более высокую производительность после загрузки начальной страницы, начальное время загрузки MPA часто быстрее, поскольку браузеру нужно загрузить только содержимое текущей страницы, а не все содержимое всего приложения;
\item[4)] MPA --- это классический способ создания веб-страниц, поэтому он совместим с большинством старых браузеров и устаревших систем~\cite{Davidson2023}.
\end{enumerate}

Основные недостатки многостраничных приложений:

\begin{enumerate}
\item[1)] поскольку MPA требуют полной перезагрузки страницы, когда пользователь взаимодействует с приложением, они обеспечивают низкую производительность, что негативно влияет на взаимодействие с пользователем;
\item[2)] MPA требуют более сложной логики на стороне сервера по сравнению с SPA, поскольку каждая страница должна проектироваться и разрабатываться отдельно, что может привести к необходимости поддерживать больше кода и повысить риск возникновения ошибок;
\item[3)] MPA требуют, чтобы сервер обрабатывал больше запросов, поскольку для загрузки каждой страницы требуется отдельный запрос, что может привести к увеличению нагрузки на сервер и увеличению времени отклика, особенно для приложений с большим количеством пользователей~\cite{Davidson2023}.
\end{enumerate}

Многостраничные приложения обычно выбираются для создания веб-сайтов с большим количеством контента, такие как новостные сайты или сайты электронной коммерции, где каждая страница представляет собой отдельный фрагмент контента или продукта~\cite{Davidson2023}\cite{Tran2022}. 
Так как цель курсовой работы --- реализация приложения для поиска авиабилетов, был выбран подход с созданием многостраничных приложений.

Для реализации программного обеспечения был выбран язык программирования C\texttt{\#} ввиду следующих причин:

\begin{enumerate}
\item[1)] на языке программирования C\texttt{\#} можно создавать многостраничные веб-приложения с помощью кроссплатформенного фреймворка ASP.NET Core;
\item[2)] фреймворк ASP.NET Identity представляет встроенную систему аутентификации и авторизации;
\item[3)] в стандартной библиотеке C\texttt{\#} реализованы необходимые структуры данных для работы с БД (такие как IEnumerable<T>, List<T> и SortedSet<T>);
\item[4)] ASP.NET MVC Framework реализует шаблон Model-View-Controller, который предназначен для отделения бизнес-логики приложения от визуализации данных, что позволяет проводить тестирование одних компонентов приложения независимо от других.
\end{enumerate}

Помимо языка программирования нужно выбрать систему управления базами данных. 
Наиболее популярные реляционные системы управления базами данных: Oracle, MySQL, Microsoft SQL Server, PostgreSQL и SQLite~\cite{Statistics1}\cite{Statistics2}.

Для реализации программного продукта была выбрана СУБД Microsoft SQL Server ввиду следующих причин:

\begin{enumerate}
\item[1)] она подходит для многопользовательских приложений;
\item[2)] может работать без использования контейнеризации;
\item[3)] язык программирования C\texttt{\#} предоставляет необходимый набор инструментов для работы с этой СУБД.
\end{enumerate}

Таким образом, с помощью языка C\texttt{\#} и СУБД Microsoft SQL Server можно реализовать программное обеспечение, которое соответствует перечисленным в аналитическом разделе требованиям.

\section{Реализация сущностей базы данных}

В листингах~\ref{lst:user.cs}--\ref{lst:service.cs} показана реализация сущностей базы данных.

\includelisting
{user.cs}{Cущность <<Пользователь>>}

\pagebreak
\includelisting
{flight.cs}{Cущность <<Рейс>>}

\includelisting
{order.cs}{Cущность <<Заказ>>}

\includelisting
{ticket.cs}{Cущность <<Билет>>}

\pagebreak
\includelisting
{plane.cs}{Cущность <<Самолет>>}

\includelisting
{service.cs}{Cущность <<Услуга>>}


\section{Реализация ограничений целостности базы данных}

В листингах~\ref{lst:constraints_users.sql}--\ref{lst:constraints_tickets_services.sql} показана реализация ограничений целостности базы данных (ограничения задаются при создании таблиц).

\includelisting
{constraints_users.sql}{Ограничения для таблицы <<Пользователи>>}

\includelisting
{constraints_orders.sql}{Ограничения для таблицы <<Заказы>>}

\includelisting
{constraints_flights.sql}{Ограничения для таблицы <<Рейсы>>}

\includelisting
{constraints_planes.sql}{Ограничения для таблицы <<Самолеты>>}

\includelisting
{constraints_services.sql}{Ограничения для таблицы <<Услуги>>}

\includelisting
{constraints_tickets.sql}{Ограничения для таблицы <<Билеты>>}

\includelisting
{constraints_tickets_services.sql}{Ограничения для вспомогательной таблицы-связки <<Билеты-Услуги>>}

\pagebreak
\section{Реализация функции на уровне базы данных}

В листинге~\ref{lst:db_function.sql} показана реализация функции на уровне базы данных, которая по идентификатору заказа считает стоимость всех билетов и услуг. 
Здесь используется функция COALESCE из Transact-SQL, которая вычисляет аргументы по порядку и возвращает текущее значение первого выражения, изначально не вычисленного как \mbox{NULL~\cite{Coalesce}}.

\includelisting
{db_function.sql}{Функция, возвращающая стоимость всех билетов и услуг конкретного заказа}

\pagebreak
\section{Реализация ролевой модели на уровне базы данных}

В листинге~\ref{lst:db_roles.sql} показана реализация ролевой модели на уровне базы данных, которая состоит из трех ролей: клиента (db\_customer), модератора (db\_moderator) и администратора (db\_admin).

\includelisting
{db_roles.sql}{Ролевая модель на уровне базы данных}

\section{Реализация интерфейса доступа к базе данных}

Для обеспечения взаимодействия приложения с базой данных были написаны интерфейсы, которые предоставляют моделям (сущностям) определенные методы для работы с данными. 
У каждой модели есть приватное поле, которое представляет собой экземпляр конкретного интерфейса.

В листингах~\ref{lst:irepository.cs}--\ref{lst:repository.cs} показаны соответственно интерфейс репозитория для сущности <<Заказ>> и реализация одного из его методов.

\includelisting
{irepository.cs}{Интерфейс репозитория для сущности <<Заказ>>}

\includelisting
{repository.cs}{Реализация одного из методов интерфейса репозитория для сущности <<Заказ>>}

\section{Тестирование разработанного функционала}

Для тестирования программного обеспечения на разных этапах разработки использовались различные методы тестирования: mock-тесты для проверки корректности реализации бизнес-логики приложения, интеграционные тесты для проверки корректности работы приложения с базой данных и тесты по сценариям использования для проверки корректности работы реализованного веб-приложения. 

В листинге~\ref{lst:mock_test.cs} показана реализация одного из mock-тестов для сущности <<Пользователь>>. 
Данный тест проверяет корректность работы метода регистрации нового пользователя.

\includelisting
{mock_test.cs}{Mock-тест для сущности <<Пользователь>>}

\pagebreak
В листинге~\ref{lst:integration_test.cs} показана реализация одного из интеграционных тестов для сущности <<Пользователь>>.

\includelisting
{integration_test.cs}{Интеграционный тест для сущности <<Пользователь>>}

\section*{Вывод из технологической части}

В ходе выполнения технологической части курсовой работы были выбраны средства реализации программного обеспечения; написан исходный код сущностей, ограничений целостности, проектируемой функции, ролевой модели базы данных; реализован интерфейс доступа к базе данных и протестирован разработанный функционал.

\chapter{Исследовательская часть}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено измерение времени выполнения запросов:

\begin{enumerate}
\item[1)]
операционная система Windows 10 Pro x64;
\item[2)]
оперативная память 16 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i7-4790K @ 4.00 ГГц.
\end{enumerate}

Измерение времени выполнения запросов проводилось на стороне сервера с помощью класса Stopwatch, который предоставляет набор методов и свойств, которые можно использовать для точного измерения затраченного времени~\cite{Stopwatch}.

\section{Исследование характеристик разработанного программного обеспечения}

Индекс --- это объект базы данных, обеспечивающий дополнительные способы быстрого
поиска и извлечения данных. 
Индекс может создаваться на одном (простой индекс) или нескольких (составной индекс) атрибутах. 
Если в таблице нет индекса, то поиск нужных строк выполняется простым сканированием по всей таблице. 
При наличии индекса время поиска нужных строк можно существенно уменьшить~\cite{Gavrilova2022}. 

Индексирование не влияет на размещение данных какой-либо таблицы в базе данных. 
Ускорение поиска данных через индекс обеспечивается за счет упорядочивания значений индексируемого атрибута (что позволяет просматривать в среднем половину индекса при линейном поиске) и за счет того, что индекс занимает меньше страниц памяти, чем сама таблица, поэтому система тратит меньше времени на чтение индекса, чем на чтение таблицы~\cite{Karpova2009}.

В Microsoft SQL Server индексы хранятся в виде сбалансированных деревьев. 
Представление индекса в виде сбалансированного дерева означает, что стоимость поиска любой строки остается относительно постоянной, независимо от того, где находится эта строка~\cite{Gavrilova2022}.

Таблица или представление может иметь индексы кластеризованные и некластеризованные. 
Кластеризованные индексы сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. 
Этими значениями являются столбцы, включенные в определение индекса. 
Существует только один кластеризованный индекс для каждой таблицы, так как строки данных могут храниться в единственном порядке. 
Строки данных в таблице хранятся в порядке сортировки только в том случае, если таблица содержит кластеризованный индекс. 
Некластеризованные индексы имеют структуру, отдельную от строк данных. 
В некластеризованном индексе содержатся значения ключа некластеризованного индекса, и каждая запись значения ключа содержит указатель на строку данных, содержащую значение ключа. 
В Microsoft SQL Server индексы создаются автоматически при определении ограничений PRIMARY KEY или UNIQUE на основе столбцов таблицы~\cite{Indices}.

Во всех таблицах базы данных, которую использует реализованное в ходе выполнения курсовой работы приложение, есть ограничение PRIMARY KEY, соответственно, Microsoft SQL Server автоматически создает кластеризованные индексы. 
В таблице <<Пользователи>> есть уникальный атрибут <<почта>>, для которого СУБД создает некластеризованный индекс. 
Имеет смысл вручную создать некластеризованный составной индекс по атрибутам <<пункт вылета>>, <<пункт прибытия>> и <<дата вылета>> для таблицы <<Рейсы>> для увеличения скорости поиска рейсов. 

Кроме того, можно вручную создать кластеризованный и некластеризованный индекс по атрибуту <<ID пользователя>> в таблице <<Заказы>> и измерить время выполнения запроса поиска заказа по идентификатору пользователя без индекса, с кластеризованным и некластеризованным индексом.

\section{Время выполнения запроса}

В листинге~\ref{lst:index.sql} приведены команды создания кластеризованного и некластеризованного индекса для таблицы <<Заказы>>.

\includelisting
{index.sql}{Создание кластеризованного и некластеризованного индекса}

В таблицах~\ref{tabular:query1}--\ref{tabular:query2} приведено время выполнения в миллисекундах запроса без индекса, с кластеризованным и некластеризованным индексом при поиске первой и последней записи в таблице соответственно.

\begin{table}[H]
\caption{Время выполнения запроса при поиске первой записи в таблице}
\label{tabular:query1}
\begin{tabular}{|>{\raggedleft}p{2cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Кол-во строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с кластеризованным индексом, мс} & \textbf{Время выполнения запроса с некластеризованным индексом, мс}
\tabularnewline
\hline
100 & 468 & 440 & 450
\tabularnewline
\hline
1000 & 471 & 421 & 439
\tabularnewline
\hline
10000 & 510 & 425 & 445
\tabularnewline
\hline
50000 & 757 & 414 & 453
\tabularnewline
\hline
100000 & 1642 & 472 & 460
\tabularnewline
\hline
250000 & 10701 & 498 & 510
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Время выполнения запроса при поиске последней записи в таблице}
\label{tabular:query2}
\begin{tabular}{|>{\raggedleft}p{2cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Кол-во строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с кластеризованным индексом, мс} & \textbf{Время выполнения запроса с некластеризованным индексом, мс}
\tabularnewline
\hline
100 & 495 & 442 & 461
\tabularnewline
\hline
1000 & 644 & 448 & 452
\tabularnewline
\hline
10000 & 715 & 457 & 470
\tabularnewline
\hline
50000 & 2136 & 440 & 445
\tabularnewline
\hline
100000 & 5978 & 498 & 510
\tabularnewline
\hline
250000 & 50571 & 524 & 520
\tabularnewline
\hline
\end{tabular}
\end{table}

На рисунках~\ref{img:graph-01}--\ref{img:graph-02} показана зависимость времени выполнения запроса в миллисекундах от количества строк в таблице.

\includeimage
    {graph-01}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость времени выполнения запроса от количества строк в таблице при поиске первой записи}
    
\includeimage
    {graph-02}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость времени выполнения запроса от количества строк в таблице при поиске последней записи}

\section*{Вывод из исследовательской части}

В ходе выполнения исследовательской части курсовой работы был проведен краткий обзор кластеризованных и некластеризованных индексов; определены таблицы и атрибуты, для которых имеет смысл создавать индексы, и проведен эксперимент по измерению времени выполнения запроса без индекса, с кластеризованным и некластеризованным индексом. 
Согласно полученным при проведении эксперимента данным, при количестве строк в таблице до 10 тысяч существенной разницы во времени выполнения запроса не наблюдается. 
При большем количестве записей время выполнения запроса без использования индекса растет в разы быстрее, а время выполнения запроса с использованием двух типов индексов остается практически неизменным. 
Разница во времени выполнения запроса с кластеризованным и некластеризованным индексом практически отсутствует. 
При 250 тысячах строк в таблице использование индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы была разработана база данных для хранения и обработки данных авиакомпании, а также веб-приложение, которое ее использует.

Были выполнены следующие задачи:

\begin{enumerate}
\item[1)] проведен обзор существующих веб-приложений для покупки авиабилетов и сформулированы требования и ограничения к разрабатываемой базе данных и приложению;
\item[2)] спроектирована архитектура базы данных, ограничения целостности и ролевая модель на уровне базы данных;
\item[3)] выбраны средства реализации и реализованы спроектированная база данных и необходимый интерфейс для взаимодействия с ней;
\item[4)] исследованы характеристики разработанного программного обеспечения.
\end{enumerate}

В ходе проведения эксперимента при выполнении исследовательской части курсовой работы было установлено, что при 250 тысячах строк в таблице использование и кластеризованного, и некластеризованного индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Презентация}
\center{\textbf{Презентация}}

\end{document}
