\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Разработка базы данных для хранения и обработки данных авиакомпании}
    {ИУ7-63Б}
    {В.~Марченко}
    {Д.~А.~Шибанова}
    {}
    {}
    
\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка 48 с., 9 рис., 7 табл., 11 источн., 1 прил.

\noindent АВИАБИЛЕТЫ, АВИАПЕРЕЛЕТЫ, БАЗЫ ДАННЫХ, ВЕБ-ПРИЛОЖЕНИЕ, РЕЛЯЦИОННАЯ МОДЕЛЬ ДАННЫХ, SQL

Объектом разработки является база данных и приложение к ней.

Цель работы: разработка базы данных для хранения и обработки данных авиакомании и веб-приложения, которое будет ее использовать.

В результате выполнения работы была разработана база данных для хранения и обработки данных авиакомании и веб-приложение, использующее эту базу данных.

Область применения результатов --- дальнейшее развитие и расширение приложения для поиска и покупки билетов на любые виды транспорта.
    
\maketableofcontents

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
БД & База данных
\tabularnewline
ПО & Программное обеспечение
\tabularnewline
СУБД & Система управления базами данных
\tabularnewline
ER-диаграмма & Диаграмма <<сущность-связь>> (от англ. entity-relationship)
\tabularnewline
GPS & Система глобального позиционирования (Global Positioning System)
\tabularnewline
ID & Идентификатор
\tabularnewline
Use case диаграмма & Диаграмма вариантов использования
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

Системы баз данных широко распространены в корпоративном мире как видимый инструмент --- сотрудники часто напрямую взаимодействуют с такими системами, чтобы отправить данные или создать отчеты. 
Но не менее часто они используются как невидимые компоненты программных систем. 
Например, веб-сайт электронной коммерции, использующий базу данных на стороне сервера для хранения информации о клиентах, товарах и продажах. 
Или система навигации GPS, использующая встроенную базу данных для управления картами дорог. 
В обоих этих примерах система баз данных скрыта от пользователя; с ней взаимодействует только код приложения~\cite{Sciore2020}.

Наряду с веб-сайтами электронной коммерции, веб-приложения для покупки авиабилетов также используют базы данных для хранения информации о пользователях, самолетах, билетах и т.~д. 
Существует мнение, что самолет --- лучший способ передвижения. 
Эту точку зрения подкрепляют несколько факторов~\cite{Ataturk2021}.
\begin{enumerate}
\item Самый быстрый путь к месту назначения.
\item Авиабилеты являются доступными для среднестатистического человека.
\item Полет --- один из самых безопасных способов путешествовать~\cite{Ataturk2021}.
\end{enumerate}

В случае создания авиакомпании сегодня не представляется возможным обойтись без веб-приложения для продажи билетов. 
Соответственно, нужна база данных для хранения информации о пользователях, билетах, воздушных суднах, услугах и т.~д.

Целью курсовой работы является разработка базы данных для хранения и обработки данных авиакомании, а также веб-приложения, которое будет ее использовать.

Задачами данной работы являются:
\begin{enumerate}
\item[1)] провести обзор существующих веб-приложений для покупки авиабилетов и сформулировать требования и ограничения к разрабатываемой базе данных и приложению;
\item[2)] спроектировать архитектуру базы данных, ограничения целостности и ролевую модель на уровне базы данных;
\item[3)] выбрать средства реализации и реализовать спроектированную базу данных и необходимый интерфейс для взаимодействия с ней;
\item[4)] исследовать характеристики разработанного программного обеспечения.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Анализ предметной области}

Одно из самых популярных средств для поиска авиабилетов --- Aviasales. 
Однако это метапоисковик билетов, и сама компания перелеты не организует. 
Из довольно известных международных компаний, у которых есть собственный флот, можно выделить следующие: Qatar Airways, Emirates, United Airlines и Etihad Airways. 

Веб-приложения приведенных организаций достаточно однотипные. 
На домашней странице пользователю сразу предлагается выбор пунктов вылета и назначения, типа билета --- в одну сторону или <<туда и обратно>>, даты вылета и обратного рейса, количества билетов и их класса. 
Помимо этого, доступны такие функции как онлайн регистрация, управление бронированием и проверка статуса рейса. 
Etihad Airways предлагает еще функцию повышения класса перелета.

Помимо основных функций, пользователь на сайтах этих компаний может найти и забронировать отель, экскурсию и т.~д. 
Также стоит отметить тот факт, что эти веб-приложения доступны на большом количестве различных языков.

\section{Требования к базе данных и приложению}

Приложение должно предоставлять пользователям возможность искать билеты на интересующие их рейсы. 
Для этого должны быть использованы следующие параметры: дата вылета, пункт вылета и пункт прибытия. 
Билеты могут быть нескольих классов. 
Помимо билетов пользователь может выбирать услуги, которые предоставляются для билетов определенных классов.

Пользователи должны иметь возможность просматривать заказ, добавлять билеты в заказ, удалять их оттуда, очищать и оплачивать заказ, добавлять и удалять услуги.
 
Должны быть реализованы регистрация и авторизация пользователей, внесение именений в личные данные и возможность просмотреть информацию о самолетах авиакомании.

\section{Модели баз данных}

\subsection{Дореляционные базы данных}

В основе любой базы данных лежит модель данных. 
Моделью данных называется формализованное описание структур единиц информации и операций над ними в информационной системе. 
Тип модели данных определяет логическую структуру базы данных и то, каким образом данные могут быть сохранены, организованы и обработаны \cite{Avrunev2018}.

К ранним моделям относят модели, предшествующие реляционной
модели данных: иерархическую, сетевую модели и модель на основе инвертированных списков. 
Иерархическая модель данных была исторически первой структурой
баз данных, видимо, из-за того, что древовидные иерархические структуры широко используются в повседневной человеческой деятельности \cite{Avrunev2018}.

Иерархическая модель данных --- представление базы данных в виде древовидной (иерархической) структуры, состоящей из объектов (данных) различных уровней \cite{Avrunev2018}.

В этой модели данные представляются как дерево связанных записей. 
Имеется один корневой (родительский) тип записи --- корень дерева. 
С ним в подчиненной связи типа 1:N находятся дочерние записи. 
Связи между записями выражаются в виде отношений предок-потомок, а у каждой записи есть ровно одна родительская запись. 
Это помогает поддерживать ссылочную целостность: когда запись удаляется из дерева, все ее потомки должны быть также
удалены \cite{Avrunev2018}.

Иерархические базы данных имеют централизованную структуру,
поэтому безопасность данных легко контролировать. 
Однако, определенные знания о физическом порядке хранения записей все же необходимы, так как отношения предок-потомок реализуются в виде физических указателей из одной записи на другую. 
Это означает, что поиск записи осуществляется методом прямого обхода дерева. 
Записи, расположенные в одной половине дерева, ищутся быстрее, чем в другой. 
Отсюда следует необходимость правильно упорядочивать записи, чтобы время их поиска было минимальным \cite{Avrunev2018}.

Достоинства иерархической модели.

\begin{enumerate}
\item Принцип построения баз данных в иерархической модели легок для понимания. 
Иерархия базы данных напоминает структуру компании или генеалогическое дерево.
\item Использование отношений предок-потомок. 
Иерархическая модель позволяет легко представлять отношения предок-потомок, например, <<А является частью В>> или <<А принадлежит В>>.
\item Быстродействие. 
В иерархической модели отношения предок-потомок реализуются в виде физических указателей из одной записи на другую, поэтому перемещение по базе данных происходит достаточно быстро. 
Поскольку структура данных в иерархической модели отличается простотой, СУБД может размещать записи предков и
потомков на диске рядом друг с другом, что позволяло свести к минимуму количество операций чтения-записи \cite{Avrunev2018}.
\end{enumerate}

Недостатки иерархической модели.

\begin{enumerate}
\item Операции манипулирования данными в иерархических системах ориентированы прежде всего на поиск информации сверху вниз, т.~е. по данному экземпляру сегмента-отца можно найти все экземпляры сегментов-сыновей. 
Обратный поиск затруднен, а часто и невозможен. 
Например, попытка реализовать запрос типа <<В скольких сборниках статей опубликовал свои статьи господин Петров?>> может оказаться весьма трудной задачей.
\item Дублирование данных на логическом уровне.
\item Для представления связи M:N необходимо дублирование деревьев.
\item В иерархической модели автоматически поддерживается целостность ссылок между предками и потомками по правилу: никакой потомок не может существовать без своего родителя. 
Целостность по ссылкам между записями, не входящими в одну иерархию, не поддерживается. 
Поэтому невозможно хранение в базе данных порожденного узла без соответствующего исходного. 
Аналогично, удаление исходного узла влечет удаление всех порожденных узлов (деревьев), связанных с ним \cite{Avrunev2018}.
\end{enumerate}

Сетевой подход к организации данных является расширением
иерархического. 
Цель разработчиков сетевой модели --- создание модели, позволяющей описывать связи M:N, чтобы одна запись могла участвовать в нескольких отношениях предок-потомок \cite{Avrunev2018}.

Сетевая модель данных базируется также на использовании представления данных в виде графа. 
C точки зрения теории графов сетевой модели соответствует произвольный граф: если в иерархической модели запись-потомок должна иметь в точности одного предка, то в сетевой модели данных потомок может иметь любое число предков. 
Вершины графа используются для интерпретации типов объектов, дуги графа используются для интерпретации типов связей между типами объектов \cite{Avrunev2018}.

Структура сетевой базы данных основана на следующих правилах:

\begin{enumerate}
\item[1)] база данных содержит любое количество типов записей и типов наборов;
\item[2)] между двумя типами записей может быть определено любое количество типов наборов;
\item[3)] тип записи может быть владельцем и одновременно членом нескольких типов наборов \cite{Avrunev2018}.
\end{enumerate}

Сложность практического использования иерархических и сетевых
СУБД заставляла искать иные способы представления данных. 
В конце 1960-х годов появились СУБД на основе инвертированных файлов, отличающиеся простотой организации и наличием весьма удобных языков манипулирования данными. Организация доступа к данным на основе инвертированных списков используется практически во всех современных реляционных СУБД, но в реляционных СУБД пользователи не имеют непосредственного доступа к инвертированным спискам (индексам) \cite{Avrunev2018}.

База данных на инвертированных списках похожа на реляционную
базу данных, т.~е. также состоит из таблиц отношений, однако ей присущи важные отличия:

\begin{enumerate}
\item[1)] допускается сложная структура атрибутов (атрибуты не обязательно атомарны);
\item[2)] строки таблиц (записи) упорядочены в некоторой последовательности, каждой строке присваивается уникальный номер, физическая упорядоченность строк всех таблиц может определяться и для всей базы данных;
\item[3)] пользователям видны и хранимые таблицы, и пути доступа к ним;
\item[4)] пользователь может управлять логическим порядком строк в каждой таблице с помощью специального инструмента --- индексов (эти индексы автоматически поддерживаются системой и явно видны пользователям) \cite{Avrunev2018}.
\end{enumerate}

Недостаток модели --- отсутствие строгого математического аппарата, отсутствие средств для описания ограничений целостности базы данных и, как следствие --- большая трудоемкость программирования запросов к базе данных. 
В некоторых системах поддерживаются ограничения уникальности значений некоторых полей, но в основном все возлагается на
прикладную программу. 
Кроме этого, такие СУБД обладают рядом ограничений на количество файлов для хранения данных, количество
связей между ними, длину записи и количество ее полей \cite{Avrunev2018}.

\subsection{Постреляционные базы данных}

Третье поколение баз данных, называемых постреляционные, начало развиваться с 90-годов ХХ века. 
Тогда появились объектные, объектно-реляционные и полуструктрированные базы данных, которые расширяют возможности реляционных баз данных и позволяют хранить и обрабатывать как атомарные значения, так и объекты со сложной структурой. 
Объектные базы данных, основанные на объектно-ориентированной парадигме, --- альтернатива реляционному подходу. 
Объектно-реляционные базы данных поддерживают обратную совместимость с реляционными базами и расширяют их
возможности. 
Полуструктурированные базы данные развиваются параллельно на основе сетевых и иерархических баз данных и позволяют работать с частично структурированными данными \cite{Vinogradov2016}.

Объектный подход к созданию баз данных ориентирован на объединение возможностей объектно-ориентированного языка программирования и базы данных для совместной работы. 
Он предполагает постоянное хранение объектов программы в базе данных и формирование запросов к базе данных на языке написания программы \cite{Vinogradov2016}.

Объектная СУБД обладает следующими возможностями:
\begin{enumerate}
\item[1)] поддерживает сложную систему типов, в том числе атомарные, структуры, коллекции и ссылки и предоставляет средства для их описания;
\item[2)] разделяет работу с литералами (неизменяемыми значениями любых типов) и объектами классов;
\item[3)] обеспечивает идентификацию объектов;
\item[4)] позволяет определять иерархии классов и интерфейсов \cite{Vinogradov2016}.
\end{enumerate}

Объектно-реляционная модель БД предоставляет пользователю следующие возможности:
\begin{enumerate}
\item[1)] хранить и обрабатывать сложные типы данных (структуры и коллекции);
\item[2)] наряду с предопределенными типами данных использовать пользовательские типы данных;
\item[3)] включать в пользовательские типы данных атрибуты и методы;
\item[4)] поддерживать уникальные идентификаторы кортежей и ссылки на них;
\item[5)] определять иерархию (наследование) типов данных \cite{Vinogradov2016}.
\end{enumerate}

Поддерживает следующие типы данных:
\begin{enumerate}
\item[1)] атомарные;
\item[2)] структуры, содержащие набор именованных полей;
\item[3)] массивы, хранящие упорядоченный набор элементов;
\item[4)] множества и мультиможества, хранящие неупорядоченный набор элементов;
\item[5)] пользовательские типы данных;
\item[6)] ссылки на объекты (кортежи) пользовательских типов данных \cite{Vinogradov2016}.
\end{enumerate}

Преимущество баз данных с фиксированной схемой, например, реляционных, --- высокая эффективность обработки и хранения больших объемов данных. 
Основным преимуществом полуструктурированных баз данных является их гибкость. 
Модель полуструктурированных данных позволяет хранить внутри данных не только значения, но и их структуру и изменять ее со временем. 
Полуструктурированные данные изображают с помощью графа. 
Вершины графа --- информационные элементы, а дуги --- связи между ними \cite{Vinogradov2016}.

Полуструктрированные данные применяют:
\begin{enumerate}
\item[1)] для описания схожей информации в БД с отличающимися схемами данных при их интеграции;
\item[2)] для представления документов (по аналогии с языком XML для веб-сайтов);
\item[3)] для работы с унаследованными БД при укрупнении, поглощении компаний (описывают обобщенную структуру исходных БД) \cite{Vinogradov2016}.
\end{enumerate}

\subsection{Реляционные базы данных}

Реляционные базы данных относят ко второму поколению баз данных. 
Они появились в начале 70-х годов ХХ века и активно использовались до конца 90-х годов ХХ века. 
Считается, что их теорию сформулировал Эдгар Кодд. 
Особенность реляционных баз данных состоит в том, что все данные и связи между ними хранятся в таблицах. 
Для определения структуры данных и манипулирования их значениями используют язык SQL (Structured Query Language --- структурированный язык запросов) \cite{Vinogradov2016}.

Реляционная модель БД --- логическая модель, базирующаяся на концептуальной модели, например, модели сущность–связь, и используемая для построения схемы (структуры) реляционной БД. 
Управление реляционной БД осуществляется реляционной СУБД \cite{Vinogradov2016}.

Факторы, обеспечившие быстрое распространение реляционной
модели:

\begin{enumerate}
\item[1)] с прагматической точки зрения база данных представляется в виде двумерных таблиц (отношений), обработка в которых не зависит от организации хранения данных в памяти;
\item[2)] с математической точки зрения реляционная база данных --- конечный набор отношений различной арности, являющихся областью приложений математической логики, теории множеств и общей алгебры, замкнутость реляционной модели (операции над отношениями дают отношение) обеспечивает основу для интерпретации выводимости, избыточности и непротиворечивости данных;
\item[3)] наличие небольшого набора абстракций, которые позволяют сравнительно просто моделировать большую часть распространенных предметных областей и допускают точные формальные определения \cite{Avrunev2018}.
\end{enumerate}

\section{Информация, подлежащая хранению в базе данных}

В базе данных нужно будет хранить информацию о шести сущностях: пользователь, заказ, билет, рейс, самолет и услуга.
\begin{enumerate}
\item Пользователь. 
Информация о зарегистрированных пользователях: роль, адрес электронной почты, пароль, имя, фамилия и дата регистрации.
\item Заказ. 
Информация о заказах зарегистрированных пользователей: заказчик билета и статус заказа.
\item Рейс. 
Информация о рейсах, на которые продаются билеты. 
Пункт вылета, пункт прибытия, дата и время вылета, дата и время прибытия.
\item Билет.
Информация о продаваемых билетах. 
Рейс, на который продается билет, ряд, место, класс, возможность возврата и стоимость. 
\item Самолет. 
Информация о самолетах, которые выполняют рейсы. 
Название комании-производителя, модель, количество мест экономкласса, бизнес-класса и первого класса.
\item Услуга. 
Информация о предоставляемых услугах. 
Наименование, стоимость, возможность получения данной услуги для билета эконом класса, бизнес-класса и первого класса.
\end{enumerate}

\section{ER-диаграмма сущностей базы данных}

На рисунке~\ref{img:er} показана диаграмма <<сущность-связь>> проектируемой базы данных в нотации Чена. 
Представлены шесть сущностей и их свойства.

\includeimage
    {er}
    {f}
    {H}
    {1\textwidth}
    {ER-диаграмма}
    
\section{Пользователи приложения}

Пользователи приложения могуть быть четырех типов: посетители, клиенты, модераторы и администраторы.

Посетитель --- неавторизованный пользователь. 
Он может только искать рейсы и билеты, просматривать самолеты компании, регистрироваться и входить в личный кабинет.

Клиент --- зарегистрированный и авторизованный пользователь. 
Он может взаимодействовать с заказом: может его создать и просмотреть, добавить и удалить билеты, добавить и удалить услуги, очистить или оплатить заказ. 
Также у клиента должна быть возможность внести изменения в свои данные --- адрес электронной почты, имя и фамилию. 

Модератор --- зарегистрированный и авторизованный пользователь, который может добавлять в базу данных новые рейсы и билеты или удалять их оттуда.

Администратор может удалять учетные записи пользователей в приложении, а также имеет полный доступ к базе данных и, соответственно, может создавать новые таблицы или удалять старые.

\pagebreak
\section{Диаграмма вариантов использования}

На рисунках~\ref{img:use-case-01}--\ref{img:use-case-03} показаны use case диаграммы для разных пользователей.

\includeimage
    {use-case-01}
    {f}
    {H}
    {.8\textwidth}
    {Взаимодействие пользователя с личными данными}
    
\includeimage
    {use-case-04}
    {f}
    {H}
    {1\textwidth}
    {Администрирование}
    
\includeimage
    {use-case-02}
    {f}
    {H}
    {1\textwidth}
    {Взаимодействие пользователя с заказом}
    
\includeimage
    {use-case-03}
    {f}
    {H}
    {1\textwidth}
    {Поиск рейсов и билетов}

\section*{Вывод из аналитической части}

В ходе выполнения аналитической части курсовой работы был проведен анализ предметной области; сформулированы требования к базе данных и приложению; выделены шесть сущностей базы данных --- пользователь, заказ, билет, рейс, услуга и самолет; проведен анализ существующих баз данных на основе формализации данных и выбрана реляционная модель, описаны пользователи приложения (посетители, клиенты, модераторы и администраторы) и пользовательские сценарии в виде use case диаграмм.

\chapter{Конструкторская часть}

\section{Описание сущностей базы данных}

В аналитической части были выделены шесть сущностей базы данных: пользователь, рейс, билет, самолет, услуга и заказ. 
На рисунке~\ref{img:db-diagram} представлена диаграмма базы данных.

\includeimage
    {db-diagram}
    {f}
    {H}
    {.9\textwidth}
    {Диаграмма базы данных}

В таблицах~\ref{tabular:users}--\ref{tabular:services} описаны атрибуты таблиц базы данных.

\begin{table}[H]
\caption{Атрибуты таблицы <<Пользователи>>}
\label{tabular:users}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Role & строка & Роль пользователя
\tabularnewline
\hline
Email & строка & Адрес электронной почты
\tabularnewline
\hline
Password & строка & Зашифрованный пароль
\tabularnewline
\hline
FirstName & строка & Имя пользователя
\tabularnewline
\hline
LastName & строка & Фамилия пользователя
\tabularnewline
\hline
RegDate & дата и время & Дата регистрации
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Заказы>>}
\label{tabular:orders}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
UserId & целое & Идентификатор пользователя --- внешний ключ
\tabularnewline
\hline
Status & строка & Статус заказа
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы-связки <<Билеты-Услуги>>}
\label{tabular:tickets_services}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
TicketId & целое & Идентификатор билета --- первичный и внешний ключ
\tabularnewline
\hline
ServiceId & целое & Идентификатор услуги --- первичный и внешний ключ
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Билеты>>}
\label{tabular:tickets}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
FlightId & целое & Идентификатор рейса --- внешний ключ
\tabularnewline
\hline
OrderId & целое & Идентификатор заказа
\tabularnewline
\hline
Row & целое & Ряд в самолете
\tabularnewline
\hline
Place & символ & Место в ряду
\tabularnewline
\hline
Class & строка & Класс билета
\tabularnewline
\hline
Refund & логический тип & Возможен ли возврат билета
\tabularnewline
\hline
Price & денежный тип & Стоимость
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Рейсы>>}
\label{tabular:flights}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
PlaneId & целое & Идентификатор самолета --- внешний ключ
\tabularnewline
\hline
DeparturePoint & строка & Пункт вылета
\tabularnewline
\hline
ArrivalPoint & строка & Пункт прибытия
\tabularnewline
\hline
DepartureDateTime & дата и время & Дата и время вылета
\tabularnewline
\hline
ArrivalDateTime & дата и время & Дата и время прибытия
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Самолеты>>}
\label{tabular:planes}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Manufacturer & строка & Название компании-производителя
\tabularnewline
\hline
Model & строка & Название модели самолета
\tabularnewline
\hline
EconomyClassNum & целое & Количество мест экономкласса
\tabularnewline
\hline
BusinessClassNum & целое & Количество мест бизнес-класса
\tabularnewline
\hline
FirstClassNum & целое & Количество мест первого класса
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Услуги>>}
\label{tabular:services}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Name & строка & Название услуги
\tabularnewline
\hline
Price & денежный тип & Стоимость услуги
\tabularnewline
\hline
EconomyClass & логический тип & Доступна ли услуга для билета экономкласса
\tabularnewline
\hline
BusinessClass & логический тип & Доступна ли услуга для билета бизнес-класса
\tabularnewline
\hline
FirstClass & логический тип & Доступна ли услуга для билета первого класса
\tabularnewline
\hline
\end{tabular}
\end{table}

\section{Описание ограничений целостности базы данных}

На данные, хранящиеся в базе, должны быть наложены определенные ограничения для обеспечения ее целостности.

Ограничения для таблицы <<Пользователи>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Роль пользователя не может отсутствовать.
Адрес электронной почты не может отсутствовать и должен быть уникальным. 
Пароль не может отсутствовать. 
Дата регистрации пользователя не должна отсутствовать.

Ограничения для таблицы <<Заказы>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор пользователя --- положительное число, внешний ключ, не должен отсутствовать. 
Статус не должен отсутствовать.

Ограничения для таблицы <<Рейсы>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор самолета --- положительное число, внешний ключ, не должен отсутствовать. 
Пункты вылета и прибытия не должны отсутствовать. 
Дата и время вылета и прибытия не должны отсутствовать, притом дата и время вылета должны быть меньше даты и время прибытия. 

Ограничения для таблицы <<Билеты>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор рейса --- положительное число, внешний ключ, не должен отсутствовать. 
Ряд в самолете --- положительное число, не должен отсутствовать. 
Место в ряду не должно отсутствовать. 
Класс не должен отсутствовать. 
Возможность возврата не должен отсутствовать. 
Стоимость --- положительное число, не должна отсутствовать.

Ограничения для таблицы <<Самолеты>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Производитель и модель не должны отсутствовать. 
Количество мест разных классов --- неотрицательные числа, не должны отсутствовать. 

Ограничения для таблицы <<Услуги>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Наименование услуги не должно отсутствовать. 
Стоимость --- положительное число, не должна отсутствовать.
Доступность для мест разных классов не должна отсутствовать.

Ограничения для таблицы-связки <<Билеты-Услуги>>. 
Идентификатор билета --- положительное число, первичный и внешний ключ. 
Идентификатор услуги --- положительное число, первичный и внешний ключ. 

\pagebreak
\section{Описание проектриуемой функции на уровне базы данных}

Пользователь приложения может заказывать билеты и услуги. 
Так как они находятся в разных таблицах, нужно выполнять два запроса для того, чтобы посчитать стоимость всех билетов и услуг, заказанных пользователем. 
Для этой цели удобно реализовать функцию, которая по идентификатору заказа будет возвращать его стоимость. 
На рисунке~\ref{img:function} представлена схема проектируемой функции.

\includeimage
    {function}
    {f}
    {H}
    {0.55\textwidth}
    {Функция, возвращающая стоимость заказа}

\section{Описание ролевой модели на уровне базы данных}

В аналитической части было указано, что в приложении есть четыре типа пользователей: посетители, клиенты, модераторы и администраторы. 
Взаимодействией пользователей с базой данных должно происходить не напрямую, а с помощью определенного промежуточного слоя. 
Таким образом, для посетителя можно вообще не создавать роль на уровне базы данных. 
При попытке зазать билет, пользователь будет переадресован на страницу регистрации. 
Для трех других типов пользователей нужно создавать роли.

Доступны три роли на уровне базы данных.
\begin{enumerate}
\item Клиент. 
Может получать информацию из таблиц <<Пользователи>>, <<Заказы>>, <<Билеты>>, <<Рейсы>>, <<Самолеты>> и <<Услуги>>. 
Может изменять данные в таблице <<Билеты>> (изменение идентификатора заказа) и информацию о себе в таблице <<Пользователи>>.
\item Модератор. 
Обладает правами клиента. 
Не может вносить изменения в таблицу <<Пользователи>>, кроме информации о себе. 
Может добавлять и удалять данные в таблицах <<Рейсы>> и <<Билеты>>.
\item Администратор. 
Обладает правами модератора. 
Может изменять все таблицы, удалять их или создавать новые (может взаимодействовать напрямую с базой данных).
\end{enumerate}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы была создана диграмма базы данных; описаны сущности базы данных; описаны проектируемые ограничения целостности базы данных; описана функция на уровне базы данных, которая считает стоимость заказа, в виде схемы алгоритма и описана проектируемая ролевая модель на уровне базы данных, которая состоит из трех ролей --- клиент, модератор и администратор.

\chapter{Технологическая часть}

\section{Средства реализации}

Веб-приложения бывают одностраничными (SPA) и многостраничными (MPA). 
Оба подхода имеют свои преимущества и недостатки. 
В таблице~\ref{tabular:spa} перечислены преимущества и недостатки одностраничных приложений.

\begin{table}[H]
\caption{Преимущества и недостатки одностраничных приложений~\cite{Bekasov2023}}
\label{tabular:spa}
\begin{tabular}{|>{\raggedleft}p{8cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Преимущества} & \textbf{Недостатки}
\tabularnewline
\hline
Быстрая загрузка и обновление страниц & Тяжелые фреймворки
\tabularnewline
\hline
Удобство использования & Интерпретируемые языки
\tabularnewline
\hline
Изолирование фронтенда и бэкенда & Поисковая оптимизация
\tabularnewline
\hline
\end{tabular}
\end{table}

Одностраничные приложения пишутся на языке JavaScript. 
Для создания многостраничного приложения можно обойтись знанием языка гипертекстовой разметки (HTML) и языка таблиц стилей (CSS) для написания клиентской части, а для написания серверной --- Python, Ruby, Java, C\texttt{\#}, Go, PHP и т.~д.~\cite{Bekasov2023}

Наиболее популярные реляционные системы управления базами данных: Oracle, MySQL, Microsoft SQL Server, PostgreSQL и SQLite~\cite{Statistics1}\cite{Statistics2}.

Для реализации программного обеспечения был выбран язык программирования C\texttt{\#} и СУБД Microsoft SQL Server ввиду следующих причин:

\begin{enumerate}
\item[1)] на языке программирования C\texttt{\#} можно создавать веб-приложения с помощью кроссплатформенного фреймворка ASP.NET Core;
\item[2)] C\texttt{\#} поддерживает СУБД Microsoft SQL Server;
\item[3)] фреймворк ASP.NET Identity представляет встроенную систему аутентификации и авторизации;
\item[4)] в стандартной библиотеке C\texttt{\#} реализованы необходимые структуры данных для работы с БД (такие как IEnumerable<T>, List<T> и SortedSet<T>).
\end{enumerate}

Таким образом, с помощью языка C\texttt{\#} и СУБД Microsoft SQL Server можно реализовать программное обеспечение, которое соответствует перечисленным в аналитическом разделе требованиям.

\section{Реализация сущностей базы данных}

В листингах~\ref{lst:user.cs}--\ref{lst:service.cs} показана реализация сущностей базы данных.

\includelisting
{user.cs}{Cущность <<Пользователь>>}

\includelisting
{flight.cs}{Cущность <<Рейс>>}

\pagebreak
\includelisting
{order.cs}{Cущность <<Заказ>>}

\includelisting
{ticket.cs}{Cущность <<Билет>>}

\includelisting
{plane.cs}{Cущность <<Самолет>>}

\pagebreak
\includelisting
{service.cs}{Cущность <<Услуга>>}

\section{Реализация ограничений целостности базы данных}

В листингах~\ref{lst:constraints_users.sql}--\ref{lst:constraints_tickets_services.sql} показана реализация ограничений целостности базы данных (ограничения задаются при создании таблиц).

\includelisting
{constraints_users.sql}{Ограничения для таблицы <<Пользователи>>}

\includelisting
{constraints_orders.sql}{Ограничения для таблицы <<Заказы>>}

\includelisting
{constraints_flights.sql}{Ограничения для таблицы <<Рейсы>>}

\includelisting
{constraints_planes.sql}{Ограничения для таблицы <<Самолеты>>}

\includelisting
{constraints_services.sql}{Ограничения для таблицы <<Услуги>>}

\pagebreak
\includelisting
{constraints_tickets.sql}{Ограничения для таблицы <<Билеты>>}

\includelisting
{constraints_tickets_services.sql}{Ограничения для вспомогательной таблицы-связки <<Билеты-Услуги>>}

\pagebreak
\section{Реализация функции на уровне базы данных}

В листинге~\ref{lst:db_function.sql} показана реализация функции на уровне базы данных, которая по идентификатору заказа считает стоимость всех билетов и услуг. 
Здесь используется функция COALESCE из Transact-SQL, которая вычисляет аргументы по порядку и возвращает текущее значение первого выражения, изначально не вычисленного как \mbox{NULL~\cite{Coalesce}}.

\includelisting
{db_function.sql}{Функция, возвращающая стоимость всех билетов и услуг конкретного заказа}

\pagebreak
\section{Реализация ролевой модели на уровне базы данных}

В листинге~\ref{lst:db_roles.sql} показана реализация ролевой модели на уровне базы данных, которая состоит из трех ролей: клиента (db\_customer), модератора (db\_modreator) и администратора (db\_admin).

\includelisting
{db_roles.sql}{Ролевая модель на уровне базы данных}

\pagebreak
\section{Реализация интерфейса доступа к базе данных}

Для обеспечения взаимодействия приложения с базой данных были написаны интерфейсы, которые предоставляют моделям (сущностям) определенные методы для работы с данными. 
У каждой модели есть приватное поле, которое представляет собой экземпляр конкретного интерфейса.

В листингах~\ref{lst:irepository.cs}--\ref{lst:repository.cs} показаны соответственно интерфейс репозитория для сущности <<Заказ>> и реализация одного из его методов.

\includelisting
{irepository.cs}{Интерфейс репозитория для сущности <<Заказ>>}

\includelisting
{repository.cs}{Реализация одного из методов интерфейса репозитория для сущности <<Заказ>>}

\section{Тестирование разработанного функционала}

Для тестирования программного обеспечения на разных этапах разработки использовались различные методы тестирования: mock-тесты для проверки корректности реализации бизнес-логики приложения, интеграционные тесты для проверки корректности работы приложения с базой данных и тесты по сценариям использования для проверки корректности работы реализованного веб-приложения. 

В листинге~\ref{lst:mock_test.cs} показана реализация одного из mock-тестов для сущности <<Пользователь>>. 
Данный тест проверяет корректность работы метода регистрации нового пользователя.

\includelisting
{mock_test.cs}{Mock-тест для сущности <<Пользователь>>}

В листинге~\ref{lst:integration_test.cs} показана реализация одного из интеграционных тестов для сущности <<Пользователь>>.

\includelisting
{integration_test.cs}{Интеграционный тест для сущности <<Пользователь>>}

\section*{Вывод из технологической части}

В ходе выполнения технологической части курсовой работы были выбраны средства реализации программного обеспечения; написан исходный код сущностей, ограничений целостности, проектируемой функции, ролевой модели базы данных; реализован интерфейс доступа к базе данных и протестирован разработанный функционал.

\chapter{Исследовательская часть}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено измерение времени выполнения запросов:

\begin{enumerate}
\item[1)]
операционная система Windows 10 Pro x64;
\item[2)]
оперативная память 16 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i7-4790K @ 4.00 ГГц.
\end{enumerate}

Измерение времени выполнения запросов проводилось на стороне сервера с помощью класса Stopwatch, который предоставляет набор методов и свойств, которые можно использовать для точного измерения затраченного времени~\cite{Stopwatch}.

\section{Исследование характеристик разработанного программного обеспечения}

Индекс --- это структура, которая определяет соответствие значения ключа записи (атрибута или группы атрибутов) и местоположения этой записи. 
Каждый индекс связан с определенной таблицей, но является внешним по отношению к таблице. 
Индекс обычно хранится в отдельном файле или отдельной области памяти. 
Пустые значения атрибутов (NULL) не индексируются. 
Индексирование используется для ускорения доступа к записям по значению ключа и не влияет на размещение данных этой таблицы. 
Ускорение поиска данных через индекс обеспечивается за счет упорядочивания значений индексируемого атрибута (что позволяет просматривать в среднем половину индекса при линейном поиске) и за счет того, что индекс занимает меньше страниц памяти, чем сама таблица, поэтому система тратит меньше времени на чтение индекса, чем на чтение таблицы~\cite{Karpova2009}.

Таблица или представление может иметь индексы кластеризованные и некластеризованные. 
Кластеризованные индексы сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. 
Этими значениями являются столбцы, включенные в определение индекса. 
Существует только один кластеризованный индекс для каждой таблицы, так как строки данных могут храниться в единственном порядке. 
Строки данных в таблице хранятся в порядке сортировки только в том случае, если таблица содержит кластеризованный индекс. 
Некластеризованные индексы имеют структуру, отдельную от строк данных. 
В некластеризованном индексе содержатся значения ключа некластеризованного индекса, и каждая запись значения ключа содержит указатель на строку данных, содержащую значение ключа. 
В Microsoft SQL Server индексы создаются автоматически при определении ограничений PRIMARY KEY или UNIQUE на основе столбцов таблицы~\cite{Indices}.

Во всех таблицах базы данных, которую использует реализованное в ходе выполнения курсовой работы приложение, есть ограничение PRIMARY KEY, соответственно, Microsoft SQL Server автоматически создает кластеризованные индексы. 
В таблице <<Пользователи>> есть уникальный атрибут <<почта>>, для которого СУБД создает некластеризованный индекс. 
Имеет смысл вручную создать некластеризованный составной индекс по атрибутам <<пункт вылета>>, <<пункт прибытия>> и <<дата вылета>> для таблицы <<Рейсы>> для увеличения скорости поиска рейсов. 

Кроме того, можно вручную создать кластеризованный индекс по атрибуту <<ID пользователя>> в таблице <<Заказы>> и измерить время выполнения запроса поиска заказа по идентификатору пользователя без индекса и с ним.

\pagebreak
\section{Время выполнения запроса}

В листинге~\ref{lst:index.sql} приведена команда создания кластеризованного индекса для таблицы <<Заказы>>.

\includelisting
{index.sql}{Создание кластеризованного индекса}

В таблицах~\ref{tabular:query1}--\ref{tabular:query2} приведено время выполнения в миллисекундах запроса без индекса и с его использованием при поиске первой и последней записи в таблице соответственно.

\begin{table}[H]
\caption{Время выполнения запроса без индекса и с его использованием при поиске первой записи в таблице}
\label{tabular:query1}
\begin{tabular}{|>{\raggedleft}p{3cm}|>{\raggedleft}p{6cm}|>{\raggedleft}p{6cm}|}
\hline
\textbf{Количество строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с индексом, мс}
\tabularnewline
\hline
100 & 468 & 440
\tabularnewline
\hline
1000 & 471 & 421
\tabularnewline
\hline
50000 & 757 & 414
\tabularnewline
\hline
100000 & 1642 & 472
\tabularnewline
\hline
250000 & 10701 & 498
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Время выполнения запроса без индекса и с его использованием при поиске последней записи в таблице}
\label{tabular:query2}
\begin{tabular}{|>{\raggedleft}p{3cm}|>{\raggedleft}p{6cm}|>{\raggedleft}p{6cm}|}
\hline
\textbf{Количество строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с индексом, мс}
\tabularnewline
\hline
100 & 495 & 442
\tabularnewline
\hline
1000 & 644 & 448
\tabularnewline
\hline
50000 & 2136 & 440
\tabularnewline
\hline
100000 & 5978 & 498
\tabularnewline
\hline
250000 & 50571 & 524
\tabularnewline
\hline
\end{tabular}
\end{table}

На рисунках~\ref{img:graph-01}--\ref{img:graph-02} показана зависимость времени выполнения запроса в миллисекундах от количества строк в таблице.

\includeimage
    {graph-01}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость времени выполнения запроса от количества строк в таблице при поиске первой записи}
    
\includeimage
    {graph-02}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость времени выполнения запроса от количества строк в таблице при поиске последней записи}

\section*{Вывод из исследовательской части}

В ходе выполнения исследовательской части курсовой работы был проведен краткий обзор кластеризованных и некластеризованных индексов; определены таблицы и атрибуты, для которых имеет смысл создавать индексы, и проведен эксперимент по измерению времени выполнения запроса без использования кластеризованного индекса и с ним. 
Согласно полученным при проведении эксперимента данным, при количестве строк в таблице до 10 тысяч существенной разницы во времени выполнения запроса не наблюдается. 
При большем количестве записей время выполнения запроса без использования индекса растет в разы быстрее, в то время как время выполнения запроса с использованием индекса остается практически неизменным. 
При 250 тысячах строк в таблице использование индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы была разработана база данных для хранения и обработки данных авиакомании, а также веб-приложение, которое ее использует.

Были выполнены следующие задачи:

\begin{enumerate}
\item[1)] проведен обзор существующих веб-приложений для покупки авиабилетов и сформулированы требования и ограничения к разрабатываемой базе данных и приложению;
\item[2)] спроектирована архитектура базы данных, ограничения целостности и ролевая модель на уровне базы данных;
\item[3)] выбраны средства реализации и реализованы спроектированная база данных и необходимый интерфейс для взаимодействия с ней;
\item[4)] исследованы характеристики разработанного программного обеспечения.
\end{enumerate}

В ходе проведения эксперимента при выполнении исследовательской части курсовой работы было установлено, что при 250 тысячах строк в таблице использование кластеризованного индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ]}
\addcontentsline{toc}{chapter}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Презентация}
\center{\textbf{Презентация}}

\end{document}
